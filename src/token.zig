const std = @import("std");
const location = @import("location.zig");

pub const Token = struct {
    toktype: Type,
    literal: []const u8,
    span: location.Span,
};

pub const Type = enum(u8) {
    illegal,
    eof,
    nop, // an empty literal

    // whitespaces
    space,
    force_space,
    math_large_space,
    tab,
    newline,

    // numbers and strings
    integer,
    float,
    text,
    other_unicode_char,
    latex_function,
    raw_latex,

    // keywords
    docclass,
    import,
    start_doc,
    defenv,
    redefenv,
    begenv,
    ends_with,
    endenv,
    phantom_begenv,
    phantom_endenv,
    mtxt,
    etxt,
    nodocclass,
    function_def,
    long_function_def,
    outer_function_def,
    long_outer_function_def,
    e_function_def,
    e_long_function_def,
    e_outer_function_def,
    e_long_outer_function_def,
    g_function_def,
    g_long_function_def,
    g_outer_function_def,
    g_long_outer_function_def,
    x_function_def,
    x_long_function_def,
    x_outer_function_def,
    x_long_outer_function_def,
    end_function_def,

    // symbols
    plus,
    minus,
    star,
    slash,
    equal,
    not_equal,
    less,
    less_equal,
    great,
    great_equal,
    left_arrow,
    right_arrow,
    double_right_arrow,
    bang,
    question,
    dollar,
    raw_dollar,
    sharp,
    at,
    percent,
    function_param,
    latex_comment,
    superscript,
    subscript,
    ampersand,
    backslash,
    short_backslash,
    vert,
    period,
    comma,
    colon,
    semicolon,
    tilde,
    left_quote,
    right_quote,
    double_quote,
    left_paren,
    right_paren,
    left_brace,
    right_brace,
    left_square_brace,
    right_square_brace,
    math_left_brace,
    math_right_brace,
    text_math_start,
    text_math_end,
    display_math_start,
    display_math_end,
    argument_splitter,

    pub const keywords = std.ComptimeStringMap(@This(), .{
        .{ "docclass", .docclass },
        .{ "import", .import },
        .{ "startdoc", .start_doc },
        .{ "defenv", .defenv },
        .{ "redefenv", .redefenv },
        .{ "begenv", .begenv },
        .{ "endswith", .ends_with },
        .{ "endenv", .endenv },
        .{ "pbegenv", .phantom_begenv },
        .{ "pendenv", .phantom_endenv },
        .{ "mtxt", .mtxt },
        .{ "etxt", .etxt },
        .{ "mst", .text_math_start },
        .{ "mnd", .text_math_end },
        .{ "dmst", .display_math_start },
        .{ "dmnd", .display_math_end },
        .{ "nodocclass", .nodocclass },
        .{ "defun", .function_def },
        .{ "ldefun", .long_function_def },
        .{ "odefun", .outer_function_def },
        .{ "lodefun", .long_outer_function_def },
        .{ "edefun", .e_function_def },
        .{ "ledefun", .e_long_function_def },
        .{ "oedefun", .e_outer_function_def },
        .{ "loedefun", .e_long_outer_function_def },
        .{ "gdefun", .g_function_def },
        .{ "lgdefun", .g_long_function_def },
        .{ "ogdefun", .g_outer_function_def },
        .{ "logdefun", .g_long_outer_function_def },
        .{ "xdefun", .x_function_def },
        .{ "lxdefun", .x_long_function_def },
        .{ "oxdefun", .x_outer_function_def },
        .{ "loxdefun", .x_long_outer_function_def },
        .{ "endfun", .end_function_def },
    });

    pub fn isKeyword(self: @This()) bool {
        return switch (self) {
            .docclass,
            .import,
            .start_doc,
            .defenv,
            .redefenv,
            .begenv,
            .ends_with,
            .endenv,
            .mtxt,
            .etxt,
            .nodocclass,
            .function_def,
            .long_function_def,
            .outer_function_def,
            .long_outer_function_def,
            .e_function_def,
            .e_long_function_def,
            .e_outer_function_def,
            .e_long_outer_function_def,
            .g_function_def,
            .g_long_function_def,
            .g_outer_function_def,
            .g_long_outer_function_def,
            .x_function_def,
            .x_long_function_def,
            .x_outer_function_def,
            .x_long_outer_function_def,
            .end_function_def,
            => true,
            else => false,
        };
    }

    pub fn canPkgName(self: @This()) bool {
        return switch (self) {
            .text, .minus, .integer => true,
            else => false,
        };
    }

    pub fn toString(self: @This()) []const u8 {
        return switch (self) {
            .illegal => "Illegal",
            .eof => "EOF",
            .nop => "Nop",
            .space => "Space",
            .force_space => "ForceSpace",
            .math_large_space => "MathLargeSpace",
            .tab => "Tab",
            .newline => "Newline",
            .integer => "Integer",
            .float => "Float",
            .text => "Text",
            .other_unicode_char => "OtherUnicodeChar",
            .latex_function => "LatexFunction",
            .raw_latex => "RawLatex",
            .docclass => "docclass",
            .import => "import",
            .start_doc => "startdoc",
            .defenv => "defenv",
            .redefenv => "redefenv",
            .begenv => "begenv",
            .ends_with => "endswith",
            .endenv => "endenv",
            .phantom_begenv => "pbegenv",
            .phantom_endenv => "pendenv",
            .mtxt => "mtxt",
            .etxt => "etxt",
            .nodocclass => "nodocclass",
            .function_def => "defun",
            .long_function_def => "ldefun",
            .outer_function_def => "odefun",
            .long_outer_function_def => "lodefun",
            .e_function_def => "edefun",
            .e_long_function_def => "ledefun",
            .e_outer_function_def => "oedefun",
            .e_long_outer_function_def => "loedefun",
            .g_function_def => "gdefun",
            .g_long_function_def => "lgdefun",
            .g_outer_function_def => "ogdefun",
            .g_long_outer_function_def => "logdefun",
            .x_function_def => "xdefun",
            .x_long_function_def => "lxdefun",
            .x_outer_function_def => "oxdefun",
            .x_long_outer_function_def => "loxdefun",
            .end_function_def => "endfun",
            .plus => "Plus",
            .minus => "Minus",
            .star => "Star",
            .slash => "Slash",
            .equal => "Equal",
            .not_equal => "NotEqual",
            .less => "Less",
            .less_equal => "LessEqual",
            .great => "Great",
            .great_equal => "GreatEqual",
            .left_arrow => "LeftArrow",
            .right_arrow => "RightArrow",
            .double_right_arrow => "DoubleRightArrow",
            .bang => "Bang",
            .question => "Question",
            .dollar => "Dollar",
            .raw_dollar => "RawDollar",
            .sharp => "Sharp",
            .at => "At",
            .percent => "Percent",
            .function_param => "FunctionParam",
            .latex_comment => "LatexComment",
            .superscript => "Superscript",
            .subscript => "Subscript",
            .ampersand => "Ampersand",
            .backslash => "Backslash",
            .short_backslash => "ShortBackslash",
            .vert => "Vert",
            .period => "Period",
            .comma => "Comma",
            .colon => "Colon",
            .semicolon => "Semicolon",
            .tilde => "Tilde",
            .left_quote => "LeftQuote",
            .right_quote => "RightQuote",
            .double_quote => "DoubleQuote",
            .left_paren => "LeftParen",
            .right_paren => "RightParen",
            .left_brace => "LeftBrace",
            .right_brace => "RightBrace",
            .left_square_brace => "LeftSquareBrace",
            .right_square_brace => "RightSquareBrace",
            .math_left_brace => "MathLeftBrace",
            .math_right_brace => "MathRightBrace",
            .text_math_start => "TextMathStart",
            .text_math_end => "TextMathEnd",
            .display_math_start => "DisplayMathStart",
            .display_math_end => "DisplayMathEnd",
            .argument_splitter => "ArgumentSplitter",
        };
    }
};
